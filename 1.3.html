<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>VECTOR STORM: ENTROPY PROTOCOL // VERTEX LUDUS BUILD V1.3</title>
    <style>
        :root {
            --bg-color: #050505;
            --terminal-green: #00ff41;
            --alert-red: #ff0033;
            --power-blue: #00ccff;
            --power-yellow: #ffcc00;
            --seeker-orange: #ff6600;
            --boss-purple: #bd00ff;
            --ui-font: 'Courier New', Courier, monospace;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--terminal-green);
            font-family: var(--ui-font);
            user-select: none;
            -webkit-user-select: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            text-shadow: 0 0 5px var(--terminal-green);
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            font-size: 1.2rem;
            font-weight: bold;
            letter-spacing: 2px;
        }

        .hud-center {
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            pointer-events: none;
        }

        .wave-text {
            font-size: 4rem;
            color: var(--terminal-green);
            opacity: 0;
            transition: opacity 0.5s;
            text-shadow: 0 0 20px var(--terminal-green);
        }

        .boss-health-container {
            position: absolute;
            top: 60px;
            left: 50%;
            transform: translateX(-50%);
            width: 50%;
            height: 10px;
            border: 2px solid var(--boss-purple);
            display: none; /* Hidden by default */
        }
        
        .boss-health-fill {
            width: 100%;
            height: 100%;
            background-color: var(--boss-purple);
            transition: width 0.1s;
        }

        .hud-bottom {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            font-size: 0.8rem;
            opacity: 0.8;
        }

        #dash-meter { color: var(--power-blue); font-weight: bold; }
        #weapon-status { color: var(--power-yellow); font-weight: bold; }
        #shield-status { color: var(--terminal-green); font-weight: bold; display: none; }

        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 5, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            pointer-events: auto;
            cursor: pointer;
        }

        h1 {
            font-size: 3rem;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 5px;
            animation: glitch 1s infinite alternate;
        }

        p { font-size: 1.2rem; margin-top: 0; }

        .btn {
            margin-top: 2rem;
            padding: 15px 40px;
            border: 2px solid var(--terminal-green);
            background: transparent;
            color: var(--terminal-green);
            font-family: var(--ui-font);
            font-size: 1.2rem;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.2);
        }

        .btn:hover {
            background: var(--terminal-green);
            color: var(--bg-color);
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.6);
        }

        .scanlines {
            position: fixed;
            left: 0; top: 0; width: 100vw; height: 100vh;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 5;
            opacity: 0.3;
        }

        @keyframes glitch {
            0% { text-shadow: 2px 0 var(--alert-red), -2px 0 blue; transform: skew(0deg); }
            20% { text-shadow: -2px 0 var(--alert-red), 2px 0 blue; transform: skew(10deg); }
            40% { text-shadow: 2px 0 var(--alert-red), -2px 0 blue; transform: skew(-5deg); }
            60% { text-shadow: 0 0 transparent; transform: skew(0deg); }
            100% { text-shadow: 2px 0 var(--alert-red), -2px 0 blue; }
        }

        #debug-info {
            position: absolute; bottom: 10px; right: 10px; font-size: 10px; color: #555; text-align: right;
        }
    </style>
</head>
<body>

    <div class="scanlines"></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div id="score-display">SCORE: 0</div>
            <div id="health-display">INTEGRITY: 100%</div>
        </div>
        
        <div id="boss-ui" class="boss-health-container">
            <div id="boss-health-bar" class="boss-health-fill"></div>
        </div>

        <div class="hud-center">
            <div id="wave-display" class="wave-text">WAVE 1</div>
        </div>

        <div class="hud-bottom">
            <div>
                <div id="dash-meter">DASH: READY</div>
                <div id="shield-status">SHIELD: ACTIVE</div>
                <div id="weapon-status">WEAPON: STANDARD</div>
            </div>
            <div>WASD: Mover | SPACE: Dash | MOUSE: Mirar/Atirar</div>
        </div>
    </div>

    <div id="start-screen">
        <h1>Vector Storm</h1>
        <p>ENTROPY PROTOCOL V.1.3</p>
        <button class="btn" onclick="GameEngine.init()">INICIALIZAR SISTEMA</button>
    </div>

    <div id="debug-info">Vertex Ludus Engine | Boss Protocol | V1.3 | 60Hz</div>
    <canvas id="gameCanvas"></canvas>

<script>
/**
 * VERTEX LUDUS ENGINE CORE V1.3
 * Architecture: ECS + Procedural Audio + Wave System + Boss Fights + Raycasting
 */

// --- AUDIO SYNTHESIS ENGINE (Web Audio API) ---
const SoundEngine = {
    ctx: null,
    init() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
    },
    playTone(freq, type, duration, vol = 0.1, slideTo = null) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        if (slideTo) {
            osc.frequency.exponentialRampToValueAtTime(slideTo, this.ctx.currentTime + duration);
        }
        
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    playNoise(duration, vol = 0.2) {
        if (!this.ctx) return;
        const bufferSize = this.ctx.sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }

        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 1000;

        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.ctx.destination);
        noise.start();
    },
    sfxShoot() { this.playTone(800, 'square', 0.1, 0.05, 600); },
    sfxRailgun() { this.playTone(1500, 'sawtooth', 0.2, 0.15, 100); this.playNoise(0.2, 0.1); },
    sfxEnemyShoot() { this.playTone(200, 'sawtooth', 0.15, 0.05); },
    sfxExplosion() { this.playNoise(0.3, 0.2); },
    sfxPowerup() { 
        this.playTone(600, 'sine', 0.1, 0.1); 
        setTimeout(() => this.playTone(900, 'sine', 0.2, 0.1), 100);
    },
    sfxDash() { this.playNoise(0.1, 0.05); this.playTone(150, 'sawtooth', 0.2, 0.05); },
    sfxHit() { this.playTone(100, 'sawtooth', 0.1, 0.1); },
    sfxShieldBreak() { this.playTone(400, 'sine', 0.3, 0.2, 100); },
    sfxBossSpawn() { 
        this.playTone(50, 'square', 2.0, 0.3, 20); 
        this.playNoise(2.0, 0.1);
    }
};

// --- MATH UTILS ---
const PI2 = Math.PI * 2;

class Vec2 {
    constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
    }
    set(x, y) { this.x = x; this.y = y; return this; }
    add(v) { this.x += v.x; this.y += v.y; return this; }
    sub(v) { this.x -= v.x; this.y -= v.y; return this; }
    mult(s) { this.x *= s; this.y *= s; return this; }
    mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    normalize() {
        const m = this.mag();
        if (m > 0) this.mult(1 / m);
        return this;
    }
    copy() { return new Vec2(this.x, this.y); }
    static dist(v1, v2) { return Math.sqrt(Math.pow(v2.x - v1.x, 2) + Math.pow(v2.y - v1.y, 2)); }
    static dot(v1, v2) { return v1.x * v2.x + v1.y * v2.y; }
}

// Distance from point p to line segment (v, w)
function distToSegment(p, v, w) {
    const l2 = Math.pow(w.x - v.x, 2) + Math.pow(w.y - v.y, 2);
    if (l2 === 0) return Vec2.dist(p, v);
    let t = ((p.x - v.x) * (w.x - v.x) + (p.y - v.y) * (w.y - v.y)) / l2;
    t = Math.max(0, Math.min(1, t));
    const projection = new Vec2(v.x + t * (w.x - v.x), v.y + t * (w.y - v.y));
    return Vec2.dist(p, projection);
}

// --- POOLING SYSTEM ---
class Pool {
    constructor(createFn, initialSize = 100) {
        this.createFn = createFn;
        this.store = [];
        for (let i = 0; i < initialSize; i++) this.store.push(createFn());
    }
    obtain() { return this.store.length > 0 ? this.store.pop() : this.createFn(); }
    free(obj) { this.store.push(obj); }
}

// --- ECS CORE ---
const ENTITY_TYPES = {
    PLAYER: 0,
    ENEMY_CHASER: 1,
    ENEMY_SHOOTER: 2,
    ENEMY_SEEKER: 7, 
    BOSS: 8, // Titan Unit
    PROJECTILE_PLAYER: 3,
    PROJECTILE_ENEMY: 4,
    PARTICLE: 5,
    POWERUP: 6,
    RAILGUN_BEAM: 9 // Visual only entity
};

const POWERUP_TYPES = { HEALTH: 0, RAILGUN: 1, SHIELD: 2 };

class Entity {
    constructor() {
        this.id = -1;
        this.active = false;
        this.type = 0;
        this.subtype = 0;
        this.pos = new Vec2();
        this.vel = new Vec2();
        this.radius = 10;
        this.rotation = 0;
        this.color = '#fff';
        this.life = 1.0;
        this.maxLife = 1.0;
        this.health = 100;
        this.damage = 10;
        this.scoreValue = 0;
        
        // Player
        this.isPlayer = false;
        this.invulnerable = 0;
        this.dashCooldown = 0;
        this.dashTime = 0;
        this.weaponTier = 0; // 0=Standard, 1=Railgun
        this.weaponTimer = 0;
        this.hasShield = false;
        
        // AI / Boss
        this.aiTimer = 0;
        this.aiState = 0; // 0: Enter, 1: Attack A, 2: Attack B
    }

    reset() {
        this.active = false;
        this.pos.set(0,0);
        this.vel.set(0,0);
        this.rotation = 0;
        this.invulnerable = 0;
        this.isPlayer = false;
        this.weaponTier = 0;
        this.weaponTimer = 0;
        this.dashCooldown = 0;
        this.dashTime = 0;
        this.aiTimer = 0;
        this.aiState = 0;
        this.hasShield = false;
    }
}

// --- GAME ENGINE ---
const GameEngine = {
    canvas: null,
    ctx: null,
    width: 0,
    height: 0,
    lastTime: 0,
    running: false,
    score: 0,
    shake: 0,
    chromaticAberration: 0, // Effect intensity
    
    // Wave System
    wave: 1,
    waveTimer: 0,
    enemiesToSpawn: 0,
    spawnTimer: 0,
    bossActive: false,
    
    entities: [],
    pool: null,

    input: { keys: {}, mouse: new Vec2(), mouseDown: false },
    config: {
        playerSpeed: 5,
        fireRate: 0.1, 
        lastFire: 0,
        dashCooldownTime: 2.0,
        dashDuration: 0.2,
        dashSpeedMult: 4.0
    },

    init() {
        if (this.running) return;
        SoundEngine.init();
        document.getElementById('start-screen').style.display = 'none';
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d', { alpha: false });
        
        window.addEventListener('resize', () => this.resize());
        this.resize();

        window.addEventListener('keydown', e => this.input.keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => this.input.keys[e.key.toLowerCase()] = false);
        window.addEventListener('mousemove', e => this.input.mouse.set(e.clientX, e.clientY));
        window.addEventListener('mousedown', () => this.input.mouseDown = true);
        window.addEventListener('mouseup', () => this.input.mouseDown = false);
        window.addEventListener('keydown', e => { if(e.code === 'Space') this.input.keys['space'] = true; });
        window.addEventListener('keyup', e => { if(e.code === 'Space') this.input.keys['space'] = false; });
        window.addEventListener('touchstart', () => this.input.mouseDown = true);
        window.addEventListener('touchend', () => this.input.mouseDown = false);

        this.pool = new Pool(() => new Entity(), 2000);
        this.entities = [];

        this.spawnPlayer();
        this.startWave(1);

        this.running = true;
        this.score = 0;
        requestAnimationFrame(t => this.loop(t));
    },

    resize() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.canvas.width = this.width;
        this.canvas.height = this.height;
    },

    startWave(num) {
        this.wave = num;
        this.spawnTimer = 0;
        this.bossActive = false;
        
        const waveEl = document.getElementById('wave-display');
        document.getElementById('boss-ui').style.display = 'none';

        if (this.wave % 5 === 0) {
            // Boss Wave
            this.enemiesToSpawn = 1; // Just the boss
            waveEl.innerText = `WARNING: BOSS DETECTED`;
            waveEl.style.color = 'var(--boss-purple)';
            SoundEngine.sfxBossSpawn();
        } else {
            this.enemiesToSpawn = 5 + Math.floor(num * 2.5);
            waveEl.innerText = `WAVE ${num}`;
            waveEl.style.color = 'var(--terminal-green)';
            SoundEngine.playTone(100, 'triangle', 0.5, 0.3);
        }
        
        waveEl.style.opacity = 1;
        setTimeout(() => waveEl.style.opacity = 0, 3000);
    },

    spawnPlayer() {
        const p = this.pool.obtain();
        p.active = true;
        p.type = ENTITY_TYPES.PLAYER;
        p.isPlayer = true;
        p.pos.set(this.width/2, this.height/2);
        p.radius = 15;
        p.health = 100;
        p.color = '#00ff41';
        this.entities.push(p);
    },

    spawnProjectile(x, y, angle, isEnemy = false) {
        const p = this.pool.obtain();
        p.active = true;
        p.type = isEnemy ? ENTITY_TYPES.PROJECTILE_ENEMY : ENTITY_TYPES.PROJECTILE_PLAYER;
        p.pos.set(x, y);
        const speed = isEnemy ? 8 : 15;
        p.vel.set(Math.cos(angle) * speed, Math.sin(angle) * speed);
        p.radius = isEnemy ? 4 : 3;
        p.life = 1.5;
        p.color = isEnemy ? '#ff0033' : '#ccff00';
        this.entities.push(p);
        
        if(isEnemy) SoundEngine.sfxEnemyShoot();
        else SoundEngine.sfxShoot();
    },

    fireRailgun(player) {
        // Instant beam
        const range = 1000;
        const endX = player.pos.x + Math.cos(player.rotation) * range;
        const endY = player.pos.y + Math.sin(player.rotation) * range;
        
        // Visual Beam Entity
        const beam = this.pool.obtain();
        beam.active = true;
        beam.type = ENTITY_TYPES.RAILGUN_BEAM;
        beam.pos.set(player.pos.x, player.pos.y);
        beam.vel.set(endX, endY); // Reuse vel as end point
        beam.life = 0.2; // Short visual duration
        beam.color = '#00ccff';
        this.entities.push(beam);

        // Raycast Damage Logic
        const start = player.pos;
        const end = new Vec2(endX, endY);
        let hitSomething = false;

        this.entities.forEach(e => {
            if (!e.active) return;
            if (e.type === ENTITY_TYPES.ENEMY_CHASER || 
                e.type === ENTITY_TYPES.ENEMY_SHOOTER || 
                e.type === ENTITY_TYPES.ENEMY_SEEKER ||
                e.type === ENTITY_TYPES.BOSS) {
                
                // Check dist to line
                const dist = distToSegment(e.pos, start, end);
                if (dist < e.radius + 10) { // +10 beam width
                    // HIT
                    hitSomething = true;
                    e.health -= 100; // Massive damage
                    this.spawnParticle(e.pos.x, e.pos.y, '#00ccff', 5);
                    
                    if (e.health <= 0) {
                       this.destroyEnemy(e);
                    }
                }
            }
        });

        SoundEngine.sfxRailgun();
        this.triggerShake(5);
        this.chromaticAberration = 10;
        
        // Pushback player
        const recoil = new Vec2(Math.cos(player.rotation), Math.sin(player.rotation)).mult(-10);
        player.pos.add(recoil);
    },

    spawnBoss() {
        const boss = this.pool.obtain();
        boss.active = true;
        boss.type = ENTITY_TYPES.BOSS;
        boss.pos.set(this.width/2, -100);
        boss.radius = 40;
        boss.maxLife = 1000 + (this.wave * 200);
        boss.health = boss.maxLife;
        boss.scoreValue = 5000;
        boss.color = '#bd00ff'; // Purple
        boss.aiState = 0; // Enter
        this.entities.push(boss);
        this.bossActive = true;
        
        const ui = document.getElementById('boss-ui');
        ui.style.display = 'block';
    },

    spawnEnemy() {
        if (this.wave % 5 === 0) {
            this.spawnBoss();
            return;
        }

        let type = ENTITY_TYPES.ENEMY_CHASER;
        const rand = Math.random();
        
        if (this.wave > 1 && rand > 0.7) type = ENTITY_TYPES.ENEMY_SHOOTER;
        if (this.wave > 2 && rand > 0.85) type = ENTITY_TYPES.ENEMY_SEEKER; 

        const e = this.pool.obtain();
        e.active = true;
        e.type = type;
        
        const side = Math.floor(Math.random() * 4);
        if (side === 0) e.pos.set(Math.random() * this.width, -50);
        else if (side === 1) e.pos.set(this.width + 50, Math.random() * this.height);
        else if (side === 2) e.pos.set(Math.random() * this.width, this.height + 50);
        else e.pos.set(-50, Math.random() * this.height);

        if (type === ENTITY_TYPES.ENEMY_CHASER) {
            e.radius = 12; e.health = 20 + (this.wave * 2); e.scoreValue = 100; e.color = '#ff0033';
        } else if (type === ENTITY_TYPES.ENEMY_SHOOTER) {
            e.radius = 18; e.health = 40 + (this.wave * 4); e.scoreValue = 300; e.color = '#ff00ff'; e.aiTimer = Math.random();
        } else if (type === ENTITY_TYPES.ENEMY_SEEKER) {
            e.radius = 10; e.health = 10 + (this.wave * 2); e.scoreValue = 150; e.color = '#ff6600';
        }
        
        this.entities.push(e);
    },

    destroyEnemy(e) {
        e.active = false;
        this.spawnParticle(e.pos.x, e.pos.y, e.color, 10);
        this.triggerShake(5);
        this.score += e.scoreValue;
        SoundEngine.sfxExplosion();
        
        // Loot Table
        if (e.type === ENTITY_TYPES.BOSS) {
            this.score += 5000;
            this.triggerShake(20);
            this.spawnParticle(e.pos.x, e.pos.y, e.color, 50);
            this.spawnPowerup(e.pos.x, e.pos.y); // Always drop on boss
            this.bossActive = false;
        } else if (Math.random() < 0.08) { // 8% chance
            this.spawnPowerup(e.pos.x, e.pos.y);
        }

        this.pool.free(e);
        // Clean up array is handled in physics loop via splice logic usually, 
        // but since we call this from multiple places, we might need to handle index carefully.
        // For now, setting active=false is safe, the render/update loops check this.
        // The cleanup happens in physics loop.
    },

    spawnPowerup(x, y) {
        const p = this.pool.obtain();
        p.active = true;
        p.type = ENTITY_TYPES.POWERUP;
        const rand = Math.random();
        if (rand < 0.4) p.subtype = POWERUP_TYPES.HEALTH;
        else if (rand < 0.7) p.subtype = POWERUP_TYPES.RAILGUN;
        else p.subtype = POWERUP_TYPES.SHIELD;

        p.pos.set(x, y);
        p.radius = 10;
        p.life = 10.0;
        
        if (p.subtype === POWERUP_TYPES.HEALTH) p.color = '#00ff41';
        else if (p.subtype === POWERUP_TYPES.RAILGUN) p.color = '#ffcc00';
        else p.color = '#ffffff';

        this.entities.push(p);
    },

    spawnParticle(x, y, color, count = 5) {
        for(let i=0; i<count; i++) {
            const p = this.pool.obtain();
            p.active = true;
            p.type = ENTITY_TYPES.PARTICLE;
            p.pos.set(x, y);
            const angle = Math.random() * PI2;
            const speed = Math.random() * 5 + 2;
            p.vel.set(Math.cos(angle) * speed, Math.sin(angle) * speed);
            p.life = Math.random() * 0.5 + 0.2;
            p.radius = Math.random() * 2 + 1;
            p.color = color;
            this.entities.push(p);
        }
    },

    triggerShake(amount) { this.shake = amount; },

    // --- SYSTEMS ---

    systemInput(dt) {
        const p = this.entities.find(e => e.isPlayer && e.active);
        if (!p) return;

        if (p.dashCooldown > 0) p.dashCooldown -= dt;
        
        let speed = this.config.playerSpeed;
        
        if (this.input.keys['space'] && p.dashCooldown <= 0 && p.dashTime <= 0) {
            p.dashTime = this.config.dashDuration;
            p.dashCooldown = this.config.dashCooldownTime;
            p.invulnerable = this.config.dashDuration;
            this.spawnParticle(p.pos.x, p.pos.y, '#00ccff', 8);
            SoundEngine.sfxDash();
        }

        if (p.dashTime > 0) {
            p.dashTime -= dt;
            speed *= this.config.dashSpeedMult;
            this.spawnParticle(p.pos.x, p.pos.y, 'rgba(0,255,255,0.5)', 1);
        }

        const dir = new Vec2(0,0);
        if (this.input.keys['w'] || this.input.keys['arrowup']) dir.y = -1;
        if (this.input.keys['s'] || this.input.keys['arrowdown']) dir.y = 1;
        if (this.input.keys['a'] || this.input.keys['arrowleft']) dir.x = -1;
        if (this.input.keys['d'] || this.input.keys['arrowright']) dir.x = 1;

        if (dir.mag() > 0) dir.normalize().mult(speed);
        p.pos.add(dir);

        p.pos.x = Math.max(p.radius, Math.min(this.width - p.radius, p.pos.x));
        p.pos.y = Math.max(p.radius, Math.min(this.height - p.radius, p.pos.y));

        p.rotation = Math.atan2(this.input.mouse.y - p.pos.y, this.input.mouse.x - p.pos.x);

        if (p.weaponTier > 0) {
            p.weaponTimer -= dt;
            if (p.weaponTimer <= 0) p.weaponTier = 0;
        }

        this.config.lastFire -= dt;
        if (this.input.mouseDown && this.config.lastFire <= 0) {
            if (p.weaponTier === 1) { // Railgun
                this.fireRailgun(p);
                this.config.lastFire = 0.8; // Slow fire rate for railgun
            } else {
                this.spawnProjectile(p.pos.x + Math.cos(p.rotation)*20, p.pos.y + Math.sin(p.rotation)*20, p.rotation);
                this.config.lastFire = this.config.fireRate;
            }
        }
    },

    systemAI(dt) {
        const player = this.entities.find(e => e.isPlayer && e.active);
        const targetPos = player ? player.pos : new Vec2(this.width/2, this.height/2);

        // Wave Management
        if (this.enemiesToSpawn > 0) {
            this.spawnTimer -= dt;
            if (this.spawnTimer <= 0) {
                this.spawnEnemy();
                this.enemiesToSpawn--;
                this.spawnTimer = 0.5;
            }
        } else if (!this.bossActive) {
            const enemiesAlive = this.entities.filter(e => e.active && (e.type === ENTITY_TYPES.ENEMY_CHASER || e.type === ENTITY_TYPES.ENEMY_SHOOTER || e.type === ENTITY_TYPES.ENEMY_SEEKER || e.type === ENTITY_TYPES.BOSS)).length;
            if (enemiesAlive === 0) {
                this.startWave(this.wave + 1);
            }
        }

        this.entities.forEach(e => {
            if (!e.active) return;
            
            // --- BOSS AI ---
            if (e.type === ENTITY_TYPES.BOSS) {
                // Update Health Bar
                const bar = document.getElementById('boss-health-bar');
                bar.style.width = `${(e.health / e.maxLife) * 100}%`;

                // State Machine
                if (e.aiState === 0) { // Enter
                    e.pos.y += 100 * dt;
                    if (e.pos.y >= 150) e.aiState = 1;
                } else {
                    // Hover movement sine wave
                    e.pos.x += Math.cos(Date.now() / 1000) * 1;
                    
                    e.aiTimer -= dt;
                    if (e.aiTimer <= 0) {
                        // Attack Pattern
                        const pattern = Math.floor(Math.random() * 2); // 0 or 1
                        if (pattern === 0) {
                            // Spiral
                            for(let i=0; i<12; i++) {
                                this.spawnProjectile(e.pos.x, e.pos.y, (i / 12) * PI2 + (Date.now()/500), true);
                            }
                        } else {
                            // Aimed Burst
                            for(let i=0; i<3; i++) {
                                setTimeout(() => {
                                    if(e.active) {
                                        const angle = Math.atan2(targetPos.y - e.pos.y, targetPos.x - e.pos.x);
                                        this.spawnProjectile(e.pos.x, e.pos.y, angle + (Math.random()-0.5)*0.5, true);
                                    }
                                }, i * 100);
                            }
                        }
                        e.aiTimer = 1.5;
                    }
                }
                e.rotation += 0.01;
                return;
            }

            // --- STANDARD ENEMY AI ---
            if (e.type === ENTITY_TYPES.ENEMY_CHASER) {
                const dir = targetPos.copy().sub(e.pos).normalize().mult(3);
                e.pos.add(dir);
                e.rotation = Math.atan2(targetPos.y - e.pos.y, targetPos.x - e.pos.x);
            } 
            else if (e.type === ENTITY_TYPES.ENEMY_SEEKER) {
                const dir = targetPos.copy().sub(e.pos).normalize().mult(6);
                e.pos.add(dir);
                e.rotation += 0.2;
            }
            else if (e.type === ENTITY_TYPES.ENEMY_SHOOTER) {
                 const dist = Vec2.dist(e.pos, targetPos);
                 if (dist > 300) {
                    const dir = targetPos.copy().sub(e.pos).normalize().mult(2);
                    e.pos.add(dir);
                 } else if (dist < 150) {
                    const dir = e.pos.copy().sub(targetPos).normalize().mult(1.5);
                    e.pos.add(dir);
                 }
                 e.rotation = Math.atan2(targetPos.y - e.pos.y, targetPos.x - e.pos.x);

                 e.aiTimer -= dt;
                 if (e.aiTimer <= 0 && dist < 600) {
                     this.spawnProjectile(e.pos.x, e.pos.y, e.rotation, true);
                     e.aiTimer = 2.0;
                 }
            }
        });
    },

    systemPhysics(dt) {
        const player = this.entities.find(e => e.isPlayer && e.active);

        for (let i = 0; i < this.entities.length; i++) {
            const e1 = this.entities[i];
            if (!e1.active) continue;

            // Integration
            if (e1.type === ENTITY_TYPES.PROJECTILE_PLAYER || 
                e1.type === ENTITY_TYPES.PROJECTILE_ENEMY || 
                e1.type === ENTITY_TYPES.PARTICLE ||
                e1.type === ENTITY_TYPES.RAILGUN_BEAM) {
                
                if (e1.type !== ENTITY_TYPES.RAILGUN_BEAM) e1.pos.add(e1.vel);
                
                e1.life -= dt;
                if (e1.life <= 0) {
                    e1.active = false;
                    this.pool.free(e1);
                    this.entities.splice(i, 1);
                    i--;
                    continue;
                }
            }

            if (e1.type === ENTITY_TYPES.POWERUP) {
                e1.life -= dt;
                if (e1.life <= 0) {
                     e1.active = false;
                     this.pool.free(e1);
                     this.entities.splice(i, 1);
                     i--;
                     continue;
                }
            }

            // Player Bullet vs Enemies
            if (e1.type === ENTITY_TYPES.PROJECTILE_PLAYER) {
                for (let j = 0; j < this.entities.length; j++) {
                    const e2 = this.entities[j];
                    if (!e2.active || (e2.type !== ENTITY_TYPES.ENEMY_CHASER && e2.type !== ENTITY_TYPES.ENEMY_SHOOTER && e2.type !== ENTITY_TYPES.ENEMY_SEEKER && e2.type !== ENTITY_TYPES.BOSS)) continue;

                    if (Vec2.dist(e1.pos, e2.pos) < e1.radius + e2.radius) {
                        e2.health -= this.config.damage = 25;
                        e1.active = false;
                        this.spawnParticle(e1.pos.x, e1.pos.y, '#ccff00', 3);
                        SoundEngine.sfxHit();

                        if (e2.health <= 0) {
                            this.destroyEnemy(e2);
                            // Cleanup e2 logic
                            this.entities.splice(j, 1);
                            if (j < i) i--; 
                            j--;
                        }
                        
                        this.pool.free(e1);
                        this.entities.splice(i, 1);
                        i--;
                        break;
                    }
                }
            }

            // Enemy Projectile vs Player
            if (e1.type === ENTITY_TYPES.PROJECTILE_ENEMY && player && player.active && player.invulnerable <= 0) {
                if (Vec2.dist(e1.pos, player.pos) < e1.radius + player.radius) {
                    if (player.hasShield) {
                        player.hasShield = false;
                        SoundEngine.sfxShieldBreak();
                        player.invulnerable = 1.0;
                        this.spawnParticle(player.pos.x, player.pos.y, '#ffffff', 20); // Shield shatter
                    } else {
                        player.health -= 15;
                        player.invulnerable = 1.0;
                        this.triggerShake(10);
                        this.spawnParticle(player.pos.x, player.pos.y, '#ff0033', 10);
                        SoundEngine.sfxHit();
                    }
                    
                    e1.active = false;
                    this.pool.free(e1);
                    this.entities.splice(i, 1);
                    i--;
                    
                    if (player.health <= 0) this.gameOver();
                }
            }

            // Powerup Pickup
            if (e1.type === ENTITY_TYPES.POWERUP && player && player.active) {
                if (Vec2.dist(e1.pos, player.pos) < e1.radius + player.radius) {
                    if (e1.subtype === POWERUP_TYPES.HEALTH) {
                        player.health = Math.min(100, player.health + 30);
                        this.spawnParticle(player.pos.x, player.pos.y, '#00ff41', 10);
                    } else if (e1.subtype === POWERUP_TYPES.RAILGUN) {
                        player.weaponTier = 1;
                        player.weaponTimer = 15.0; // 15 seconds of railgun
                        this.spawnParticle(player.pos.x, player.pos.y, '#ffcc00', 10);
                    } else if (e1.subtype === POWERUP_TYPES.SHIELD) {
                        player.hasShield = true;
                        this.spawnParticle(player.pos.x, player.pos.y, '#ffffff', 10);
                    }
                    SoundEngine.sfxPowerup();
                    e1.active = false;
                    this.pool.free(e1);
                    this.entities.splice(i, 1);
                    i--;
                }
            }
            
            // Body Collision
            if (player && player.active && player.invulnerable <= 0) {
                 if ((e1.type === ENTITY_TYPES.ENEMY_CHASER || e1.type === ENTITY_TYPES.ENEMY_SHOOTER || e1.type === ENTITY_TYPES.ENEMY_SEEKER || e1.type === ENTITY_TYPES.BOSS) && e1.active) {
                    if (Vec2.dist(e1.pos, player.pos) < e1.radius + player.radius) {
                        
                         if (player.hasShield) {
                            player.hasShield = false;
                            SoundEngine.sfxShieldBreak();
                            player.invulnerable = 2.0; // Longer invuln for body collision w/ shield
                            const push = player.pos.copy().sub(e1.pos).normalize().mult(100);
                            player.pos.add(push);
                            this.spawnParticle(player.pos.x, player.pos.y, '#ffffff', 20);
                        } else {
                            player.health -= 20;
                            player.invulnerable = 1.0;
                            this.triggerShake(15);
                            this.spawnParticle(player.pos.x, player.pos.y, '#ff0000', 15);
                            SoundEngine.sfxHit();

                            const push = player.pos.copy().sub(e1.pos).normalize().mult(50);
                            player.pos.add(push);
                        }

                        // Seeker explode
                        if (e1.type === ENTITY_TYPES.ENEMY_SEEKER) {
                            this.destroyEnemy(e1);
                            this.entities.splice(i, 1);
                            i--;
                        }

                        if (player.health <= 0) this.gameOver();
                    }
                 }
            } else if (player) {
                player.invulnerable -= dt;
            }
        }
    },

    systemRender() {
        // Shake
        let tx = 0, ty = 0;
        if (this.shake > 0) {
            tx = (Math.random() - 0.5) * this.shake;
            ty = (Math.random() - 0.5) * this.shake;
            this.shake *= 0.9;
            if (this.shake < 0.5) this.shake = 0;
        }

        // Chromatic Aberration Simulation
        if (this.chromaticAberration > 0.5) {
             this.ctx.globalCompositeOperation = 'lighter';
             this.ctx.save();
             this.ctx.translate(5, 0); // Red shift
             this.chromaticAberration *= 0.9;
        }

        this.ctx.save();
        this.ctx.translate(tx, ty);

        this.ctx.fillStyle = 'rgba(5, 5, 5, 0.4)'; 
        this.ctx.fillRect(-10, -10, this.width+20, this.height+20); 

        // Grid
        this.ctx.strokeStyle = 'rgba(0, 255, 65, 0.1)';
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        const gridSize = 50;
        for(let x=0; x<this.width; x+=gridSize) {
            this.ctx.moveTo(x, 0); this.ctx.lineTo(x, this.height);
        }
        for(let y=0; y<this.height; y+=gridSize) {
            this.ctx.moveTo(0, y); this.ctx.lineTo(this.width, y);
        }
        this.ctx.stroke();

        // Entities
        this.entities.forEach(e => {
            if (!e.active) return;

            this.ctx.save();
            this.ctx.translate(e.pos.x, e.pos.y);
            this.ctx.rotate(e.rotation);

            this.ctx.shadowBlur = 10;
            this.ctx.shadowColor = e.color;
            this.ctx.fillStyle = e.color;
            this.ctx.strokeStyle = e.color;

            if (e.isPlayer) {
                if (e.invulnerable > 0 && Math.floor(Date.now() / 100) % 2 === 0) this.ctx.globalAlpha = 0.5;
                if (e.dashTime > 0) this.ctx.scale(1.2, 0.8);

                this.ctx.beginPath();
                this.ctx.moveTo(15, 0);
                this.ctx.lineTo(-10, 10);
                this.ctx.lineTo(-5, 0);
                this.ctx.lineTo(-10, -10);
                this.ctx.closePath();
                this.ctx.stroke(); 
                
                // Shield Visual
                if (e.hasShield) {
                    this.ctx.beginPath();
                    this.ctx.arc(0, 0, 25, 0, PI2);
                    this.ctx.strokeStyle = '#ffffff';
                    this.ctx.lineWidth = 2;
                    this.ctx.stroke();
                }
            } 
            else if (e.type === ENTITY_TYPES.BOSS) {
                // Hexagon Shape
                this.ctx.beginPath();
                for (let i = 0; i < 6; i++) {
                    const angle = (i / 6) * PI2;
                    this.ctx.lineTo(Math.cos(angle) * e.radius, Math.sin(angle) * e.radius);
                }
                this.ctx.closePath();
                this.ctx.lineWidth = 3;
                this.ctx.stroke();
                // Inner core
                this.ctx.beginPath();
                this.ctx.arc(0, 0, e.radius/2, 0, PI2);
                this.ctx.fill();
            }
            else if (e.type === ENTITY_TYPES.ENEMY_CHASER) {
                this.ctx.beginPath();
                this.ctx.moveTo(10, 0);
                this.ctx.lineTo(-5, 5);
                this.ctx.lineTo(-5, -5);
                this.ctx.closePath();
                this.ctx.stroke();
            }
            else if (e.type === ENTITY_TYPES.ENEMY_SEEKER) {
                this.ctx.beginPath();
                this.ctx.moveTo(10, 0);
                this.ctx.lineTo(-8, 6);
                this.ctx.lineTo(-8, -6);
                this.ctx.closePath();
                this.ctx.fill();
            }
            else if (e.type === ENTITY_TYPES.ENEMY_SHOOTER) {
                this.ctx.strokeRect(-8, -8, 16, 16);
                this.ctx.beginPath();
                this.ctx.moveTo(0,0);
                this.ctx.lineTo(12,0);
                this.ctx.stroke();
            }
            else if (e.type === ENTITY_TYPES.RAILGUN_BEAM) {
                // Draw line from 0,0 (player pos because of translate) to calculated endpoint
                // We need to untranslate for the beam endpoint logic or pass relative coords
                // Easiest is to just draw a long rect
                this.ctx.fillStyle = e.color;
                this.ctx.shadowBlur = 20;
                this.ctx.globalAlpha = e.life * 5; // Fade out
                this.ctx.fillRect(0, -2, 1000, 4); // 1000px range
            }
            else if (e.type === ENTITY_TYPES.PROJECTILE_PLAYER || e.type === ENTITY_TYPES.PROJECTILE_ENEMY) {
                this.ctx.beginPath();
                this.ctx.arc(0, 0, e.radius, 0, PI2);
                this.ctx.fill();
            }
            else if (e.type === ENTITY_TYPES.PARTICLE) {
                this.ctx.globalAlpha = e.life;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, e.radius, 0, PI2);
                this.ctx.fill();
            }
            else if (e.type === ENTITY_TYPES.POWERUP) {
                const scale = 1 + Math.sin(Date.now() / 200) * 0.2;
                this.ctx.scale(scale, scale);
                if (e.subtype === POWERUP_TYPES.HEALTH) {
                    this.ctx.fillText("+", -4, 4);
                    this.ctx.strokeRect(-6, -6, 12, 12);
                } else if (e.subtype === POWERUP_TYPES.RAILGUN) {
                    this.ctx.fillText("R", -4, 4);
                    this.ctx.strokeRect(-6, -6, 12, 12);
                } else {
                    this.ctx.beginPath();
                    this.ctx.arc(0,0, 8, 0, PI2);
                    this.ctx.stroke();
                }
            }

            this.ctx.restore();
        });
        
        this.ctx.restore();
        if (this.chromaticAberration > 0.5) this.ctx.restore(); // Restore from light blend

        // Update UI
        document.getElementById('score-display').innerText = `SCORE: ${this.score.toString().padStart(6, '0')}`;
        
        const p = this.entities.find(e => e.isPlayer);
        if (p) {
            document.getElementById('health-display').innerText = `INTEGRITY: ${Math.max(0, Math.floor(p.health))}%`;
            
            const dashEl = document.getElementById('dash-meter');
            if (p.dashCooldown > 0) {
                dashEl.innerText = `DASH: ${(p.dashCooldown).toFixed(1)}s`;
                dashEl.style.color = '#555';
            } else {
                dashEl.innerText = "DASH: READY";
                dashEl.style.color = 'var(--power-blue)';
            }

            const shieldEl = document.getElementById('shield-status');
            shieldEl.style.display = p.hasShield ? 'block' : 'none';

            const weaponEl = document.getElementById('weapon-status');
            if (p.weaponTier === 1) {
                weaponEl.innerText = `WEAPON: RAILGUN (${Math.ceil(p.weaponTimer)}s)`;
                weaponEl.style.color = 'var(--power-yellow)';
            } else {
                weaponEl.innerText = "WEAPON: STANDARD";
                weaponEl.style.color = '#555';
            }
        }
    },

    loop(timestamp) {
        if (!this.running) return;
        const dt = (timestamp - this.lastTime) / 1000;
        this.lastTime = timestamp;
        const safeDt = Math.min(dt, 0.1);

        this.systemInput(safeDt);
        this.systemAI(safeDt);
        this.systemPhysics(safeDt);
        this.systemRender();

        requestAnimationFrame(t => this.loop(t));
    },

    gameOver() {
        this.running = false;
        const screen = document.getElementById('start-screen');
        screen.style.display = 'flex';
        screen.querySelector('h1').innerText = "SYSTEM FAILURE";
        screen.querySelector('p').innerText = `FINAL SCORE: ${this.score}`;
        screen.querySelector('button').innerText = "REBOOT SYSTEM";
    }
};
</script>
</body>
</html>
