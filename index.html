<!DOCTYPE html>
<html lang="pt-BR">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0, user-scalable=no">
    <title>VECTOR STORM: ENTROPY PROTOCOL // VERTEX LUDUS BUILD V1.2</title>
    <style>
        :root {
            --bg-color: #050505;
            --terminal-green: #00ff41;
            --alert-red: #ff0033;
            --power-blue: #00ccff;
            --power-yellow: #ffcc00;
            --seeker-orange: #ff6600;
            --ui-font: 'Courier New', Courier, monospace;
        }

        body, html {
            margin: 0;
            padding: 0;
            width: 100%;
            height: 100%;
            overflow: hidden;
            background-color: var(--bg-color);
            color: var(--terminal-green);
            font-family: var(--ui-font);
            user-select: none;
            -webkit-user-select: none;
        }

        canvas {
            display: block;
            width: 100%;
            height: 100%;
        }

        #ui-layer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            pointer-events: none;
            display: flex;
            flex-direction: column;
            justify-content: space-between;
            padding: 20px;
            box-sizing: border-box;
            text-shadow: 0 0 5px var(--terminal-green);
        }

        .hud-top {
            display: flex;
            justify-content: space-between;
            font-size: 1.2rem;
            font-weight: bold;
            letter-spacing: 2px;
        }

        .hud-center {
            position: absolute;
            top: 20%;
            width: 100%;
            text-align: center;
            pointer-events: none;
        }

        .wave-text {
            font-size: 4rem;
            color: var(--terminal-green);
            opacity: 0;
            transition: opacity 0.5s;
            text-shadow: 0 0 20px var(--terminal-green);
        }

        .hud-bottom {
            display: flex;
            justify-content: space-between;
            align-items: flex-end;
            font-size: 0.8rem;
            opacity: 0.8;
        }

        #dash-meter { color: var(--power-blue); font-weight: bold; }
        #weapon-status { color: var(--power-yellow); font-weight: bold; }

        #start-screen {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background: rgba(5, 5, 5, 0.95);
            display: flex;
            flex-direction: column;
            align-items: center;
            justify-content: center;
            z-index: 10;
            pointer-events: auto;
            cursor: pointer;
        }

        h1 {
            font-size: 3rem;
            margin-bottom: 0.5rem;
            text-transform: uppercase;
            letter-spacing: 5px;
            animation: glitch 1s infinite alternate;
        }

        p { font-size: 1.2rem; margin-top: 0; }

        .btn {
            margin-top: 2rem;
            padding: 15px 40px;
            border: 2px solid var(--terminal-green);
            background: transparent;
            color: var(--terminal-green);
            font-family: var(--ui-font);
            font-size: 1.2rem;
            text-transform: uppercase;
            cursor: pointer;
            transition: all 0.2s;
            box-shadow: 0 0 10px rgba(0, 255, 65, 0.2);
        }

        .btn:hover {
            background: var(--terminal-green);
            color: var(--bg-color);
            box-shadow: 0 0 20px rgba(0, 255, 65, 0.6);
        }

        .scanlines {
            position: fixed;
            left: 0; top: 0; width: 100vw; height: 100vh;
            background: linear-gradient(to bottom, rgba(255,255,255,0), rgba(255,255,255,0) 50%, rgba(0,0,0,0.2) 50%, rgba(0,0,0,0.2));
            background-size: 100% 4px;
            pointer-events: none;
            z-index: 5;
            opacity: 0.3;
        }

        @keyframes glitch {
            0% { text-shadow: 2px 0 var(--alert-red), -2px 0 blue; transform: skew(0deg); }
            20% { text-shadow: -2px 0 var(--alert-red), 2px 0 blue; transform: skew(10deg); }
            40% { text-shadow: 2px 0 var(--alert-red), -2px 0 blue; transform: skew(-5deg); }
            60% { text-shadow: 0 0 transparent; transform: skew(0deg); }
            100% { text-shadow: 2px 0 var(--alert-red), -2px 0 blue; }
        }

        #debug-info {
            position: absolute; bottom: 10px; right: 10px; font-size: 10px; color: #555; text-align: right;
        }
    </style>
</head>
<body>

    <div class="scanlines"></div>

    <div id="ui-layer">
        <div class="hud-top">
            <div id="score-display">SCORE: 0</div>
            <div id="health-display">INTEGRITY: 100%</div>
        </div>
        
        <div class="hud-center">
            <div id="wave-display" class="wave-text">WAVE 1</div>
        </div>

        <div class="hud-bottom">
            <div>
                <div id="dash-meter">DASH: READY</div>
                <div id="weapon-status">WEAPON: STANDARD</div>
            </div>
            <div>WASD: Mover | SPACE: Dash | MOUSE: Mirar/Atirar</div>
        </div>
    </div>

    <div id="start-screen">
        <h1>Vector Storm</h1>
        <p>ENTROPY PROTOCOL V.1.2</p>
        <button class="btn" onclick="GameEngine.init()">INICIALIZAR SISTEMA</button>
    </div>

    <div id="debug-info">Vertex Ludus Engine | Audio Synth | V1.2 | 60Hz</div>
    <canvas id="gameCanvas"></canvas>

<script>
/**
 * VERTEX LUDUS ENGINE CORE V1.2
 * Architecture: ECS + Procedural Audio + Wave System
 */

// --- AUDIO SYNTHESIS ENGINE (Web Audio API) ---
const SoundEngine = {
    ctx: null,
    init() {
        window.AudioContext = window.AudioContext || window.webkitAudioContext;
        this.ctx = new AudioContext();
    },
    playTone(freq, type, duration, vol = 0.1) {
        if (!this.ctx) return;
        const osc = this.ctx.createOscillator();
        const gain = this.ctx.createGain();
        osc.type = type;
        osc.frequency.setValueAtTime(freq, this.ctx.currentTime);
        
        // Envelope
        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

        osc.connect(gain);
        gain.connect(this.ctx.destination);
        osc.start();
        osc.stop(this.ctx.currentTime + duration);
    },
    playNoise(duration, vol = 0.2) {
        if (!this.ctx) return;
        const bufferSize = this.ctx.sampleRate * duration;
        const buffer = this.ctx.createBuffer(1, bufferSize, this.ctx.sampleRate);
        const data = buffer.getChannelData(0);
        for (let i = 0; i < bufferSize; i++) {
            data[i] = Math.random() * 2 - 1;
        }

        const noise = this.ctx.createBufferSource();
        noise.buffer = buffer;
        const gain = this.ctx.createGain();
        
        // Lowpass filter for explosion thud
        const filter = this.ctx.createBiquadFilter();
        filter.type = 'lowpass';
        filter.frequency.value = 1000;

        gain.gain.setValueAtTime(vol, this.ctx.currentTime);
        gain.gain.exponentialRampToValueAtTime(0.01, this.ctx.currentTime + duration);

        noise.connect(filter);
        filter.connect(gain);
        gain.connect(this.ctx.destination);
        noise.start();
    },
    sfxShoot() { this.playTone(800, 'square', 0.1, 0.05); },
    sfxEnemyShoot() { this.playTone(200, 'sawtooth', 0.15, 0.05); },
    sfxExplosion() { this.playNoise(0.3, 0.2); },
    sfxPowerup() { 
        this.playTone(600, 'sine', 0.1, 0.1); 
        setTimeout(() => this.playTone(900, 'sine', 0.2, 0.1), 100);
    },
    sfxDash() { this.playNoise(0.1, 0.05); this.playTone(150, 'sawtooth', 0.2, 0.05); },
    sfxHit() { this.playTone(100, 'sawtooth', 0.1, 0.1); }
};

// --- MATH UTILS & CONSTANTS ---
const PI2 = Math.PI * 2;

class Vec2 {
    constructor(x = 0, y = 0) {
        this.x = x;
        this.y = y;
    }
    set(x, y) { this.x = x; this.y = y; return this; }
    add(v) { this.x += v.x; this.y += v.y; return this; }
    sub(v) { this.x -= v.x; this.y -= v.y; return this; }
    mult(s) { this.x *= s; this.y *= s; return this; }
    mag() { return Math.sqrt(this.x * this.x + this.y * this.y); }
    normalize() {
        const m = this.mag();
        if (m > 0) this.mult(1 / m);
        return this;
    }
    copy() { return new Vec2(this.x, this.y); }
    static dist(v1, v2) { return Math.sqrt(Math.pow(v2.x - v1.x, 2) + Math.pow(v2.y - v1.y, 2)); }
}

// --- POOLING SYSTEM ---
class Pool {
    constructor(createFn, initialSize = 100) {
        this.createFn = createFn;
        this.store = [];
        for (let i = 0; i < initialSize; i++) this.store.push(createFn());
    }
    obtain() { return this.store.length > 0 ? this.store.pop() : this.createFn(); }
    free(obj) { this.store.push(obj); }
}

// --- ECS CORE ---
const ENTITY_TYPES = {
    PLAYER: 0,
    ENEMY_CHASER: 1,
    ENEMY_SHOOTER: 2,
    ENEMY_SEEKER: 7, // New Kamikaze Unit
    PROJECTILE_PLAYER: 3,
    PROJECTILE_ENEMY: 4,
    PARTICLE: 5,
    POWERUP: 6
};

const POWERUP_TYPES = { HEALTH: 0, SPREAD: 1 };

class Entity {
    constructor() {
        this.id = -1;
        this.active = false;
        this.type = 0;
        this.subtype = 0;
        this.pos = new Vec2();
        this.vel = new Vec2();
        this.radius = 10;
        this.rotation = 0;
        this.color = '#fff';
        this.life = 1.0;
        this.maxLife = 1.0;
        this.health = 100;
        this.damage = 10;
        this.scoreValue = 0;
        
        // Player Specific
        this.isPlayer = false;
        this.invulnerable = 0;
        this.dashCooldown = 0;
        this.dashTime = 0;
        this.weaponTier = 0;
        this.weaponTimer = 0;
        
        // Enemy AI State
        this.aiTimer = 0;
    }

    reset() {
        this.active = false;
        this.pos.set(0,0);
        this.vel.set(0,0);
        this.rotation = 0;
        this.invulnerable = 0;
        this.isPlayer = false;
        this.weaponTier = 0;
        this.weaponTimer = 0;
        this.dashCooldown = 0;
        this.dashTime = 0;
        this.aiTimer = 0;
    }
}

// --- GAME ENGINE ---
const GameEngine = {
    canvas: null,
    ctx: null,
    width: 0,
    height: 0,
    lastTime: 0,
    running: false,
    score: 0,
    shake: 0,
    
    // Wave System
    wave: 1,
    waveTimer: 0,
    enemiesToSpawn: 0,
    spawnTimer: 0,
    
    entities: [],
    pool: null,

    input: {
        keys: {},
        mouse: new Vec2(),
        mouseDown: false
    },

    config: {
        playerSpeed: 5,
        fireRate: 0.1, 
        lastFire: 0,
        dashCooldownTime: 2.0,
        dashDuration: 0.2,
        dashSpeedMult: 4.0
    },

    init() {
        if (this.running) return;
        
        // Audio Init
        SoundEngine.init();

        // Setup DOM
        document.getElementById('start-screen').style.display = 'none';
        this.canvas = document.getElementById('gameCanvas');
        this.ctx = this.canvas.getContext('2d', { alpha: false });
        
        window.addEventListener('resize', () => this.resize());
        this.resize();

        window.addEventListener('keydown', e => this.input.keys[e.key.toLowerCase()] = true);
        window.addEventListener('keyup', e => this.input.keys[e.key.toLowerCase()] = false);
        window.addEventListener('mousemove', e => this.input.mouse.set(e.clientX, e.clientY));
        window.addEventListener('mousedown', () => this.input.mouseDown = true);
        window.addEventListener('mouseup', () => this.input.mouseDown = false);
        window.addEventListener('keydown', e => { if(e.code === 'Space') this.input.keys['space'] = true; });
        window.addEventListener('keyup', e => { if(e.code === 'Space') this.input.keys['space'] = false; });
        window.addEventListener('touchstart', () => this.input.mouseDown = true);
        window.addEventListener('touchend', () => this.input.mouseDown = false);

        this.pool = new Pool(() => new Entity(), 1500);
        this.entities = [];

        this.spawnPlayer();
        this.startWave(1);

        this.running = true;
        this.score = 0;
        requestAnimationFrame(t => this.loop(t));
    },

    resize() {
        this.width = window.innerWidth;
        this.height = window.innerHeight;
        this.canvas.width = this.width;
        this.canvas.height = this.height;
    },

    startWave(num) {
        this.wave = num;
        this.enemiesToSpawn = 5 + Math.floor(num * 2.5);
        this.spawnTimer = 0;
        
        const waveEl = document.getElementById('wave-display');
        waveEl.innerText = `WAVE ${num}`;
        waveEl.style.opacity = 1;
        setTimeout(() => waveEl.style.opacity = 0, 2000);
        
        SoundEngine.playTone(100, 'triangle', 0.5, 0.3); // Wave start sound
    },

    spawnPlayer() {
        const p = this.pool.obtain();
        p.active = true;
        p.type = ENTITY_TYPES.PLAYER;
        p.isPlayer = true;
        p.pos.set(this.width/2, this.height/2);
        p.radius = 15;
        p.health = 100;
        p.color = '#00ff41';
        this.entities.push(p);
    },

    spawnProjectile(x, y, angle, isEnemy = false) {
        const p = this.pool.obtain();
        p.active = true;
        p.type = isEnemy ? ENTITY_TYPES.PROJECTILE_ENEMY : ENTITY_TYPES.PROJECTILE_PLAYER;
        p.pos.set(x, y);
        const speed = isEnemy ? 8 : 15;
        p.vel.set(Math.cos(angle) * speed, Math.sin(angle) * speed);
        p.radius = isEnemy ? 4 : 3;
        p.life = 1.5;
        p.color = isEnemy ? '#ff0033' : '#ccff00';
        this.entities.push(p);
        
        if(isEnemy) SoundEngine.sfxEnemyShoot();
        else SoundEngine.sfxShoot();
    },

    spawnEnemy() {
        // Difficulty Logic
        let type = ENTITY_TYPES.ENEMY_CHASER;
        const rand = Math.random();
        
        if (this.wave > 1 && rand > 0.7) type = ENTITY_TYPES.ENEMY_SHOOTER;
        if (this.wave > 2 && rand > 0.85) type = ENTITY_TYPES.ENEMY_SEEKER; // Kamikaze

        const e = this.pool.obtain();
        e.active = true;
        e.type = type;
        
        const side = Math.floor(Math.random() * 4);
        if (side === 0) e.pos.set(Math.random() * this.width, -50);
        else if (side === 1) e.pos.set(this.width + 50, Math.random() * this.height);
        else if (side === 2) e.pos.set(Math.random() * this.width, this.height + 50);
        else e.pos.set(-50, Math.random() * this.height);

        // Stats based on type
        if (type === ENTITY_TYPES.ENEMY_CHASER) {
            e.radius = 12;
            e.health = 20 + (this.wave * 2);
            e.scoreValue = 100;
            e.color = '#ff0033';
        } else if (type === ENTITY_TYPES.ENEMY_SHOOTER) {
            e.radius = 18;
            e.health = 40 + (this.wave * 4);
            e.scoreValue = 300;
            e.color = '#ff00ff';
            e.aiTimer = Math.random() * 2;
        } else if (type === ENTITY_TYPES.ENEMY_SEEKER) {
            e.radius = 10;
            e.health = 10 + (this.wave * 2);
            e.scoreValue = 150;
            e.color = '#ff6600'; // Orange
        }
        
        this.entities.push(e);
    },

    spawnPowerup(x, y) {
        const p = this.pool.obtain();
        p.active = true;
        p.type = ENTITY_TYPES.POWERUP;
        p.subtype = Math.random() > 0.5 ? POWERUP_TYPES.HEALTH : POWERUP_TYPES.SPREAD;
        p.pos.set(x, y);
        p.radius = 10;
        p.life = 10.0;
        p.color = p.subtype === POWERUP_TYPES.HEALTH ? '#00ff41' : '#00ccff';
        this.entities.push(p);
    },

    spawnParticle(x, y, color, count = 5) {
        for(let i=0; i<count; i++) {
            const p = this.pool.obtain();
            p.active = true;
            p.type = ENTITY_TYPES.PARTICLE;
            p.pos.set(x, y);
            const angle = Math.random() * PI2;
            const speed = Math.random() * 5 + 2;
            p.vel.set(Math.cos(angle) * speed, Math.sin(angle) * speed);
            p.life = Math.random() * 0.5 + 0.2;
            p.radius = Math.random() * 2 + 1;
            p.color = color;
            this.entities.push(p);
        }
    },

    triggerShake(amount) { this.shake = amount; },

    // --- SYSTEMS ---

    systemInput(dt) {
        const p = this.entities.find(e => e.isPlayer && e.active);
        if (!p) return;

        if (p.dashCooldown > 0) p.dashCooldown -= dt;
        
        let speed = this.config.playerSpeed;
        
        if (this.input.keys['space'] && p.dashCooldown <= 0 && p.dashTime <= 0) {
            p.dashTime = this.config.dashDuration;
            p.dashCooldown = this.config.dashCooldownTime;
            p.invulnerable = this.config.dashDuration;
            this.spawnParticle(p.pos.x, p.pos.y, '#00ccff', 8);
            SoundEngine.sfxDash();
        }

        if (p.dashTime > 0) {
            p.dashTime -= dt;
            speed *= this.config.dashSpeedMult;
            this.spawnParticle(p.pos.x, p.pos.y, 'rgba(0,255,255,0.5)', 1);
        }

        const dir = new Vec2(0,0);
        if (this.input.keys['w'] || this.input.keys['arrowup']) dir.y = -1;
        if (this.input.keys['s'] || this.input.keys['arrowdown']) dir.y = 1;
        if (this.input.keys['a'] || this.input.keys['arrowleft']) dir.x = -1;
        if (this.input.keys['d'] || this.input.keys['arrowright']) dir.x = 1;

        if (dir.mag() > 0) dir.normalize().mult(speed);
        p.pos.add(dir);

        p.pos.x = Math.max(p.radius, Math.min(this.width - p.radius, p.pos.x));
        p.pos.y = Math.max(p.radius, Math.min(this.height - p.radius, p.pos.y));

        p.rotation = Math.atan2(this.input.mouse.y - p.pos.y, this.input.mouse.x - p.pos.x);

        if (p.weaponTier > 0) {
            p.weaponTimer -= dt;
            if (p.weaponTimer <= 0) p.weaponTier = 0;
        }

        this.config.lastFire -= dt;
        if (this.input.mouseDown && this.config.lastFire <= 0) {
            this.spawnProjectile(p.pos.x + Math.cos(p.rotation)*20, p.pos.y + Math.sin(p.rotation)*20, p.rotation);
            if (p.weaponTier === 1) {
                this.spawnProjectile(p.pos.x + Math.cos(p.rotation)*20, p.pos.y + Math.sin(p.rotation)*20, p.rotation - 0.2);
                this.spawnProjectile(p.pos.x + Math.cos(p.rotation)*20, p.pos.y + Math.sin(p.rotation)*20, p.rotation + 0.2);
            }
            this.config.lastFire = this.config.fireRate;
        }
    },

    systemAI(dt) {
        const player = this.entities.find(e => e.isPlayer && e.active);
        const targetPos = player ? player.pos : new Vec2(this.width/2, this.height/2);

        // Wave Management
        if (this.enemiesToSpawn > 0) {
            this.spawnTimer -= dt;
            if (this.spawnTimer <= 0) {
                this.spawnEnemy();
                this.enemiesToSpawn--;
                this.spawnTimer = 0.5; // Spawn delay
            }
        } else {
            // Check if wave clear
            const enemiesAlive = this.entities.filter(e => e.active && (e.type === ENTITY_TYPES.ENEMY_CHASER || e.type === ENTITY_TYPES.ENEMY_SHOOTER || e.type === ENTITY_TYPES.ENEMY_SEEKER)).length;
            if (enemiesAlive === 0) {
                this.startWave(this.wave + 1);
            }
        }

        this.entities.forEach(e => {
            if (!e.active) return;
            
            if (e.type === ENTITY_TYPES.ENEMY_CHASER) {
                const dir = targetPos.copy().sub(e.pos).normalize().mult(3);
                e.pos.add(dir);
                e.rotation = Math.atan2(targetPos.y - e.pos.y, targetPos.x - e.pos.x);
            } 
            else if (e.type === ENTITY_TYPES.ENEMY_SEEKER) {
                // Kamikaze: Fast, no fear
                const dir = targetPos.copy().sub(e.pos).normalize().mult(6);
                e.pos.add(dir);
                // Rotate wildly
                e.rotation += 0.2;
            }
            else if (e.type === ENTITY_TYPES.ENEMY_SHOOTER) {
                 const dist = Vec2.dist(e.pos, targetPos);
                 if (dist > 300) {
                    const dir = targetPos.copy().sub(e.pos).normalize().mult(2);
                    e.pos.add(dir);
                 } else if (dist < 150) {
                    const dir = e.pos.copy().sub(targetPos).normalize().mult(1.5);
                    e.pos.add(dir);
                 }
                 
                 e.rotation = Math.atan2(targetPos.y - e.pos.y, targetPos.x - e.pos.x);

                 e.aiTimer -= dt;
                 if (e.aiTimer <= 0 && dist < 600) {
                     this.spawnProjectile(e.pos.x, e.pos.y, e.rotation, true);
                     e.aiTimer = 2.0;
                 }
            }
        });
    },

    systemPhysics(dt) {
        const player = this.entities.find(e => e.isPlayer && e.active);

        for (let i = 0; i < this.entities.length; i++) {
            const e1 = this.entities[i];
            if (!e1.active) continue;

            if (e1.type === ENTITY_TYPES.PROJECTILE_PLAYER || 
                e1.type === ENTITY_TYPES.PROJECTILE_ENEMY || 
                e1.type === ENTITY_TYPES.PARTICLE) {
                e1.pos.add(e1.vel);
                e1.life -= dt;
                if (e1.life <= 0) {
                    e1.active = false;
                    this.pool.free(e1);
                    this.entities.splice(i, 1);
                    i--;
                    continue;
                }
            }

            if (e1.type === ENTITY_TYPES.POWERUP) {
                e1.life -= dt;
                if (e1.life <= 0) {
                     e1.active = false;
                     this.pool.free(e1);
                     this.entities.splice(i, 1);
                     i--;
                     continue;
                }
            }

            // Player Bullet vs Enemies
            if (e1.type === ENTITY_TYPES.PROJECTILE_PLAYER) {
                for (let j = 0; j < this.entities.length; j++) {
                    const e2 = this.entities[j];
                    if (!e2.active || (e2.type !== ENTITY_TYPES.ENEMY_CHASER && e2.type !== ENTITY_TYPES.ENEMY_SHOOTER && e2.type !== ENTITY_TYPES.ENEMY_SEEKER)) continue;

                    if (Vec2.dist(e1.pos, e2.pos) < e1.radius + e2.radius) {
                        e2.health -= this.config.damage = 25;
                        e1.active = false;
                        this.spawnParticle(e1.pos.x, e1.pos.y, '#ccff00', 3);
                        SoundEngine.sfxHit();

                        if (e2.health <= 0) {
                            e2.active = false;
                            this.spawnParticle(e2.pos.x, e2.pos.y, e2.color, 10);
                            this.triggerShake(5);
                            this.score += e2.scoreValue;
                            SoundEngine.sfxExplosion();
                            
                            if (Math.random() < 0.10) this.spawnPowerup(e2.pos.x, e2.pos.y);

                            this.pool.free(e2);
                            this.entities.splice(j, 1);
                            if (j < i) i--; 
                            j--;
                        }
                        
                        this.pool.free(e1);
                        this.entities.splice(i, 1);
                        i--;
                        break;
                    }
                }
            }

            // Enemy Bullet vs Player
            if (e1.type === ENTITY_TYPES.PROJECTILE_ENEMY && player && player.active && player.invulnerable <= 0) {
                if (Vec2.dist(e1.pos, player.pos) < e1.radius + player.radius) {
                    player.health -= 15;
                    player.invulnerable = 1.0;
                    this.triggerShake(10);
                    this.spawnParticle(player.pos.x, player.pos.y, '#ff0033', 10);
                    SoundEngine.sfxHit();
                    
                    e1.active = false;
                    this.pool.free(e1);
                    this.entities.splice(i, 1);
                    i--;
                    
                    if (player.health <= 0) this.gameOver();
                }
            }

            // Powerup Pickup
            if (e1.type === ENTITY_TYPES.POWERUP && player && player.active) {
                if (Vec2.dist(e1.pos, player.pos) < e1.radius + player.radius) {
                    if (e1.subtype === POWERUP_TYPES.HEALTH) {
                        player.health = Math.min(100, player.health + 30);
                        this.spawnParticle(player.pos.x, player.pos.y, '#00ff41', 10);
                    } else if (e1.subtype === POWERUP_TYPES.SPREAD) {
                        player.weaponTier = 1;
                        player.weaponTimer = 10.0;
                        this.spawnParticle(player.pos.x, player.pos.y, '#00ccff', 10);
                    }
                    SoundEngine.sfxPowerup();
                    e1.active = false;
                    this.pool.free(e1);
                    this.entities.splice(i, 1);
                    i--;
                }
            }
            
            // Enemy Body Collision
            if (player && player.active && player.invulnerable <= 0) {
                 if ((e1.type === ENTITY_TYPES.ENEMY_CHASER || e1.type === ENTITY_TYPES.ENEMY_SHOOTER || e1.type === ENTITY_TYPES.ENEMY_SEEKER) && e1.active) {
                    if (Vec2.dist(e1.pos, player.pos) < e1.radius + player.radius) {
                        player.health -= 20;
                        player.invulnerable = 1.0;
                        this.triggerShake(15);
                        this.spawnParticle(player.pos.x, player.pos.y, '#ff0000', 15);
                        SoundEngine.sfxHit();

                        const push = player.pos.copy().sub(e1.pos).normalize().mult(50);
                        player.pos.add(push);

                        // Seeker explodes on contact
                        if (e1.type === ENTITY_TYPES.ENEMY_SEEKER) {
                            e1.health = 0;
                            e1.active = false;
                            this.spawnParticle(e1.pos.x, e1.pos.y, '#ff6600', 15);
                            SoundEngine.sfxExplosion();
                            this.pool.free(e1);
                            this.entities.splice(i, 1);
                            i--;
                        }

                        if (player.health <= 0) this.gameOver();
                    }
                 }
            } else if (player) {
                player.invulnerable -= dt;
            }
        }
    },

    systemRender() {
        // Screen Shake
        let tx = 0, ty = 0;
        if (this.shake > 0) {
            tx = (Math.random() - 0.5) * this.shake;
            ty = (Math.random() - 0.5) * this.shake;
            this.shake *= 0.9;
            if (this.shake < 0.5) this.shake = 0;
        }

        this.ctx.save();
        this.ctx.translate(tx, ty);

        // Clear w/ Warp Effect logic
        this.ctx.fillStyle = 'rgba(5, 5, 5, 0.4)'; 
        this.ctx.fillRect(-10, -10, this.width+20, this.height+20); 

        // Dynamic Grid
        const player = this.entities.find(e => e.isPlayer);
        let gridOffset = 0;
        if (player) { // Fake movement effect based on player pos
             gridOffset = (player.pos.x + player.pos.y) * 0.1;
        }

        this.ctx.strokeStyle = 'rgba(0, 255, 65, 0.1)';
        this.ctx.lineWidth = 1;
        this.ctx.beginPath();
        const gridSize = 50;
        
        // Draw grid with slight offset
        const time = Date.now() / 1000;
        for(let x=0; x<this.width; x+=gridSize) {
            this.ctx.moveTo(x, 0); this.ctx.lineTo(x, this.height);
        }
        for(let y=0; y<this.height; y+=gridSize) {
            this.ctx.moveTo(0, y); this.ctx.lineTo(this.width, y);
        }
        this.ctx.stroke();

        // Render Entities
        this.entities.forEach(e => {
            if (!e.active) return;

            this.ctx.save();
            this.ctx.translate(e.pos.x, e.pos.y);
            this.ctx.rotate(e.rotation);

            this.ctx.shadowBlur = 10;
            this.ctx.shadowColor = e.color;
            this.ctx.fillStyle = e.color;
            this.ctx.strokeStyle = e.color;

            if (e.isPlayer) {
                if (e.invulnerable > 0 && Math.floor(Date.now() / 100) % 2 === 0) this.ctx.globalAlpha = 0.5;
                if (e.dashTime > 0) this.ctx.scale(1.2, 0.8);

                this.ctx.beginPath();
                this.ctx.moveTo(15, 0);
                this.ctx.lineTo(-10, 10);
                this.ctx.lineTo(-5, 0);
                this.ctx.lineTo(-10, -10);
                this.ctx.closePath();
                this.ctx.stroke(); 
                
                if (e.weaponTier > 0) {
                    this.ctx.strokeStyle = '#00ccff';
                    this.ctx.strokeRect(-5, -5, 10, 10);
                }
            } 
            else if (e.type === ENTITY_TYPES.ENEMY_CHASER) {
                this.ctx.beginPath();
                this.ctx.moveTo(10, 0);
                this.ctx.lineTo(-5, 5);
                this.ctx.lineTo(-5, -5);
                this.ctx.closePath();
                this.ctx.stroke();
            }
            else if (e.type === ENTITY_TYPES.ENEMY_SEEKER) {
                // Triangle Kamikaze
                this.ctx.beginPath();
                this.ctx.moveTo(10, 0);
                this.ctx.lineTo(-8, 6);
                this.ctx.lineTo(-8, -6);
                this.ctx.closePath();
                this.ctx.fill();
            }
            else if (e.type === ENTITY_TYPES.ENEMY_SHOOTER) {
                this.ctx.strokeRect(-8, -8, 16, 16);
                this.ctx.beginPath();
                this.ctx.moveTo(0,0);
                this.ctx.lineTo(12,0);
                this.ctx.stroke();
            }
            else if (e.type === ENTITY_TYPES.PROJECTILE_PLAYER || e.type === ENTITY_TYPES.PROJECTILE_ENEMY) {
                this.ctx.beginPath();
                this.ctx.arc(0, 0, e.radius, 0, PI2);
                this.ctx.fill();
            }
            else if (e.type === ENTITY_TYPES.PARTICLE) {
                this.ctx.globalAlpha = e.life;
                this.ctx.beginPath();
                this.ctx.arc(0, 0, e.radius, 0, PI2);
                this.ctx.fill();
            }
            else if (e.type === ENTITY_TYPES.POWERUP) {
                const scale = 1 + Math.sin(Date.now() / 200) * 0.2;
                this.ctx.scale(scale, scale);
                if (e.subtype === POWERUP_TYPES.HEALTH) {
                    this.ctx.fillText("+", -4, 4);
                    this.ctx.strokeRect(-6, -6, 12, 12);
                } else {
                    this.ctx.fillText("W", -4, 4);
                    this.ctx.arc(0, 0, 8, 0, PI2);
                    this.ctx.stroke();
                }
            }

            this.ctx.restore();
        });
        
        this.ctx.restore();

        // Update UI
        document.getElementById('score-display').innerText = `SCORE: ${this.score.toString().padStart(6, '0')}`;
        
        const p = this.entities.find(e => e.isPlayer);
        if (p) {
            document.getElementById('health-display').innerText = `INTEGRITY: ${Math.max(0, Math.floor(p.health))}%`;
            
            const dashEl = document.getElementById('dash-meter');
            if (p.dashCooldown > 0) {
                dashEl.innerText = `DASH: ${(p.dashCooldown).toFixed(1)}s`;
                dashEl.style.color = '#555';
            } else {
                dashEl.innerText = "DASH: READY";
                dashEl.style.color = 'var(--power-blue)';
            }

            const weaponEl = document.getElementById('weapon-status');
            if (p.weaponTier > 0) {
                weaponEl.innerText = `WEAPON: TRIPLE (${Math.ceil(p.weaponTimer)}s)`;
                weaponEl.style.color = 'var(--power-yellow)';
            } else {
                weaponEl.innerText = "WEAPON: STANDARD";
                weaponEl.style.color = '#555';
            }
        }
    },

    loop(timestamp) {
        if (!this.running) return;
        const dt = (timestamp - this.lastTime) / 1000;
        this.lastTime = timestamp;
        const safeDt = Math.min(dt, 0.1);

        this.systemInput(safeDt);
        this.systemAI(safeDt);
        this.systemPhysics(safeDt);
        this.systemRender();

        requestAnimationFrame(t => this.loop(t));
    },

    gameOver() {
        this.running = false;
        const screen = document.getElementById('start-screen');
        screen.style.display = 'flex';
        screen.querySelector('h1').innerText = "SYSTEM FAILURE";
        screen.querySelector('p').innerText = `FINAL SCORE: ${this.score}`;
        screen.querySelector('button').innerText = "REBOOT SYSTEM";
    }
};
</script>
</body>
</html>
